function f(e,n,r){function o(u,c){var a;Object.defineProperty(u,"_zod",{value:u._zod??{},enumerable:!1}),(a=u._zod).traits??(a.traits=new Set),u._zod.traits.add(e),n(u,c);for(const l in s.prototype)l in u||Object.defineProperty(u,l,{value:s.prototype[l].bind(u)});u._zod.constr=s,u._zod.def=c}const t=r?.Parent??Object;class i extends t{}Object.defineProperty(i,"name",{value:e});function s(u){var c;const a=r?.Parent?new i:this;o(a,u),(c=a._zod).deferred??(c.deferred=[]);for(const l of a._zod.deferred)l();return a}return Object.defineProperty(s,"init",{value:o}),Object.defineProperty(s,Symbol.hasInstance,{value:u=>r?.Parent&&u instanceof r.Parent?!0:u?._zod?.traits?.has(e)}),Object.defineProperty(s,"name",{value:e}),s}class g extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}}class G extends Error{constructor(n){super(`Encountered unidirectional transform during encode: ${n}`),this.name="ZodEncodeError"}}const J={};function w(e){return J}function q(e){const n=Object.values(e).filter(o=>typeof o=="number");return Object.entries(e).filter(([o,t])=>n.indexOf(+o)===-1).map(([o,t])=>t)}function H(e,n){return typeof n=="bigint"?n.toString():n}function D(e){return{get value(){{const n=e();return Object.defineProperty(this,"value",{value:n}),n}}}}function T(e){const n=e.startsWith("^")?1:0,r=e.endsWith("$")?e.length-1:e.length;return e.slice(n,r)}const N=Symbol("evaluating");function p(e,n,r){let o;Object.defineProperty(e,n,{get(){if(o!==N)return o===void 0&&(o=N,o=r()),o},set(t){Object.defineProperty(e,n,{value:t})},configurable:!0})}function I(e,n,r){Object.defineProperty(e,n,{value:r,writable:!0,enumerable:!0,configurable:!0})}function x(...e){const n={};for(const r of e){const o=Object.getOwnPropertyDescriptors(r);Object.assign(n,o)}return Object.defineProperties({},n)}const L="captureStackTrace"in Error?Error.captureStackTrace:(...e)=>{};function j(e){return typeof e=="object"&&e!==null&&!Array.isArray(e)}function V(e){if(j(e)===!1)return!1;const n=e.constructor;if(n===void 0)return!0;const r=n.prototype;return!(j(r)===!1||Object.prototype.hasOwnProperty.call(r,"isPrototypeOf")===!1)}function Q(e){return V(e)?{...e}:Array.isArray(e)?[...e]:e}const X=new Set(["string","number","symbol"]);function S(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function M(e,n,r){const o=new e._zod.constr(n??e._zod.def);return(!n||r?.parent)&&(o._zod.parent=e),o}function z(e){return{}}function Y(e){return Object.keys(e).filter(n=>e[n]._zod.optin==="optional"&&e[n]._zod.optout==="optional")}function ee(e,n){const r=e._zod.def,o=x(e._zod.def,{get shape(){const t={};for(const i in n){if(!(i in r.shape))throw new Error(`Unrecognized key: "${i}"`);n[i]&&(t[i]=r.shape[i])}return I(this,"shape",t),t},checks:[]});return M(e,o)}function ne(e,n){if(!V(n))throw new Error("Invalid input to extend: expected a plain object");const r=e._zod.def.checks;if(r&&r.length>0)throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");const t=x(e._zod.def,{get shape(){const i={...e._zod.def.shape,...n};return I(this,"shape",i),i},checks:[]});return M(e,t)}function b(e,n=0){if(e.aborted===!0)return!0;for(let r=n;r<e.issues.length;r++)if(e.issues[r]?.continue!==!0)return!0;return!1}function A(e,n){return n.map(r=>{var o;return(o=r).path??(o.path=[]),r.path.unshift(e),r})}function P(e){return typeof e=="string"?e:e?.message}function y(e,n,r){const o={...e,path:e.path??[]};if(!e.message){const t=P(e.inst?._zod.def?.error?.(e))??P(n?.error?.(e))??P(r.customError?.(e))??P(r.localeError?.(e))??"Invalid input";o.message=t}return delete o.inst,delete o.continue,n?.reportInput||delete o.input,o}const B=(e,n)=>{e.name="$ZodError",Object.defineProperty(e,"_zod",{value:e._zod,enumerable:!1}),Object.defineProperty(e,"issues",{value:n,enumerable:!1}),e.message=JSON.stringify(n,H,2),Object.defineProperty(e,"toString",{value:()=>e.message,enumerable:!1})},re=f("$ZodError",B),E=f("$ZodError",B,{Parent:Error}),te=e=>(n,r,o,t)=>{const i=o?Object.assign(o,{async:!1}):{async:!1},s=n._zod.run({value:r,issues:[]},i);if(s instanceof Promise)throw new g;if(s.issues.length){const u=new(t?.Err??e)(s.issues.map(c=>y(c,i,w())));throw L(u,t?.callee),u}return s.value},oe=te(E),se=e=>async(n,r,o,t)=>{const i=o?Object.assign(o,{async:!0}):{async:!0};let s=n._zod.run({value:r,issues:[]},i);if(s instanceof Promise&&(s=await s),s.issues.length){const u=new(t?.Err??e)(s.issues.map(c=>y(c,i,w())));throw L(u,t?.callee),u}return s.value},ie=se(E),ue=e=>(n,r,o)=>{const t=o?{...o,async:!1}:{async:!1},i=n._zod.run({value:r,issues:[]},t);if(i instanceof Promise)throw new g;return i.issues.length?{success:!1,error:new(e??re)(i.issues.map(s=>y(s,t,w())))}:{success:!0,data:i.value}},K=ue(E),ce=e=>async(n,r,o)=>{const t=o?Object.assign(o,{async:!0}):{async:!0};let i=n._zod.run({value:r,issues:[]},t);return i instanceof Promise&&(i=await i),i.issues.length?{success:!1,error:new e(i.issues.map(s=>y(s,t,w())))}:{success:!0,data:i.value}},F=ce(E),ae=e=>{const n=e?`[\\s\\S]{${e?.minimum??0},${e?.maximum??""}}`:"[\\s\\S]*";return new RegExp(`^${n}$`)},le=/^-?\d+(?:\.\d+)?/,fe=/^(?:true|false)$/i,pe={major:4,minor:1,patch:12},h=f("$ZodType",(e,n)=>{var r;e??(e={}),e._zod.def=n,e._zod.bag=e._zod.bag||{},e._zod.version=pe;const o=[...e._zod.def.checks??[]];e._zod.traits.has("$ZodCheck")&&o.unshift(e);for(const t of o)for(const i of t._zod.onattach)i(e);if(o.length===0)(r=e._zod).deferred??(r.deferred=[]),e._zod.deferred?.push(()=>{e._zod.run=e._zod.parse});else{const t=(s,u,c)=>{let a=b(s),l;for(const d of u){if(d._zod.def.when){if(!d._zod.def.when(s))continue}else if(a)continue;const m=s.issues.length,Z=d._zod.check(s);if(Z instanceof Promise&&c?.async===!1)throw new g;if(l||Z instanceof Promise)l=(l??Promise.resolve()).then(async()=>{await Z,s.issues.length!==m&&(a||(a=b(s,m)))});else{if(s.issues.length===m)continue;a||(a=b(s,m))}}return l?l.then(()=>s):s},i=(s,u,c)=>{if(b(s))return s.aborted=!0,s;const a=t(u,o,c);if(a instanceof Promise){if(c.async===!1)throw new g;return a.then(l=>e._zod.parse(l,c))}return e._zod.parse(a,c)};e._zod.run=(s,u)=>{if(u.skipChecks)return e._zod.parse(s,u);if(u.direction==="backward"){const a=e._zod.parse({value:s.value,issues:[]},{...u,skipChecks:!0});return a instanceof Promise?a.then(l=>i(l,s,u)):i(a,s,u)}const c=e._zod.parse(s,u);if(c instanceof Promise){if(u.async===!1)throw new g;return c.then(a=>t(a,o,u))}return t(c,o,u)}}e["~standard"]={validate:t=>{try{const i=K(e,t);return i.success?{value:i.data}:{issues:i.error?.issues}}catch{return F(e,t).then(s=>s.success?{value:s.data}:{issues:s.error?.issues})}},vendor:"zod",version:1}}),de=f("$ZodString",(e,n)=>{h.init(e,n),e._zod.pattern=[...e?._zod.bag?.patterns??[]].pop()??ae(e._zod.bag),e._zod.parse=(r,o)=>{if(n.coerce)try{r.value=String(r.value)}catch{}return typeof r.value=="string"||r.issues.push({expected:"string",code:"invalid_type",input:r.value,inst:e}),r}}),he=f("$ZodNumber",(e,n)=>{h.init(e,n),e._zod.pattern=e._zod.bag.pattern??le,e._zod.parse=(r,o)=>{if(n.coerce)try{r.value=Number(r.value)}catch{}const t=r.value;if(typeof t=="number"&&!Number.isNaN(t)&&Number.isFinite(t))return r;const i=typeof t=="number"?Number.isNaN(t)?"NaN":Number.isFinite(t)?void 0:"Infinity":void 0;return r.issues.push({expected:"number",code:"invalid_type",input:t,inst:e,...i?{received:i}:{}}),r}}),_e=f("$ZodBoolean",(e,n)=>{h.init(e,n),e._zod.pattern=fe,e._zod.parse=(r,o)=>{if(n.coerce)try{r.value=!!r.value}catch{}const t=r.value;return typeof t=="boolean"||r.issues.push({expected:"boolean",code:"invalid_type",input:t,inst:e}),r}});function R(e,n,r){e.issues.length&&n.issues.push(...A(r,e.issues)),n.value[r]=e.value}const me=f("$ZodArray",(e,n)=>{h.init(e,n),e._zod.parse=(r,o)=>{const t=r.value;if(!Array.isArray(t))return r.issues.push({expected:"array",code:"invalid_type",input:t,inst:e}),r;r.value=Array(t.length);const i=[];for(let s=0;s<t.length;s++){const u=t[s],c=n.element._zod.run({value:u,issues:[]},o);c instanceof Promise?i.push(c.then(a=>R(a,r,s))):R(c,r,s)}return i.length?Promise.all(i).then(()=>r):r}});function k(e,n,r,o){e.issues.length&&n.issues.push(...A(r,e.issues)),e.value===void 0?r in o&&(n.value[r]=void 0):n.value[r]=e.value}function ze(e){const n=Object.keys(e.shape);for(const o of n)if(!e.shape?.[o]?._zod?.traits?.has("$ZodType"))throw new Error(`Invalid element at key "${o}": expected a Zod schema`);const r=Y(e.shape);return{...e,keys:n,keySet:new Set(n),numKeys:n.length,optionalKeys:new Set(r)}}function ve(e,n,r,o,t,i){const s=[],u=t.keySet,c=t.catchall._zod,a=c.def.type;for(const l of Object.keys(n)){if(u.has(l))continue;if(a==="never"){s.push(l);continue}const d=c.run({value:n[l],issues:[]},o);d instanceof Promise?e.push(d.then(m=>k(m,r,l,n))):k(d,r,l,n)}return s.length&&r.issues.push({code:"unrecognized_keys",keys:s,input:n,inst:i}),e.length?Promise.all(e).then(()=>r):r}const ge=f("$ZodObject",(e,n)=>{if(h.init(e,n),!Object.getOwnPropertyDescriptor(n,"shape")?.get){const u=n.shape;Object.defineProperty(n,"shape",{get:()=>{const c={...u};return Object.defineProperty(n,"shape",{value:c}),c}})}const o=D(()=>ze(n));p(e._zod,"propValues",()=>{const u=n.shape,c={};for(const a in u){const l=u[a]._zod;if(l.values){c[a]??(c[a]=new Set);for(const d of l.values)c[a].add(d)}}return c});const t=j,i=n.catchall;let s;e._zod.parse=(u,c)=>{s??(s=o.value);const a=u.value;if(!t(a))return u.issues.push({expected:"object",code:"invalid_type",input:a,inst:e}),u;u.value={};const l=[],d=s.shape;for(const m of s.keys){const v=d[m]._zod.run({value:a[m],issues:[]},c);v instanceof Promise?l.push(v.then(W=>k(W,u,m,a))):k(v,u,m,a)}return i?ve(l,a,u,c,o.value,e):l.length?Promise.all(l).then(()=>u):u}});function U(e,n,r,o){for(const i of e)if(i.issues.length===0)return n.value=i.value,n;const t=e.filter(i=>!b(i));return t.length===1?(n.value=t[0].value,t[0]):(n.issues.push({code:"invalid_union",input:n.value,inst:r,errors:e.map(i=>i.issues.map(s=>y(s,o,w())))}),n)}const be=f("$ZodUnion",(e,n)=>{h.init(e,n),p(e._zod,"optin",()=>n.options.some(t=>t._zod.optin==="optional")?"optional":void 0),p(e._zod,"optout",()=>n.options.some(t=>t._zod.optout==="optional")?"optional":void 0),p(e._zod,"values",()=>{if(n.options.every(t=>t._zod.values))return new Set(n.options.flatMap(t=>Array.from(t._zod.values)))}),p(e._zod,"pattern",()=>{if(n.options.every(t=>t._zod.pattern)){const t=n.options.map(i=>i._zod.pattern);return new RegExp(`^(${t.map(i=>T(i.source)).join("|")})$`)}});const r=n.options.length===1,o=n.options[0]._zod.run;e._zod.parse=(t,i)=>{if(r)return o(t,i);let s=!1;const u=[];for(const c of n.options){const a=c._zod.run({value:t.value,issues:[]},i);if(a instanceof Promise)u.push(a),s=!0;else{if(a.issues.length===0)return a;u.push(a)}}return s?Promise.all(u).then(c=>U(c,t,e,i)):U(u,t,e,i)}}),we=f("$ZodDiscriminatedUnion",(e,n)=>{be.init(e,n);const r=e._zod.parse;p(e._zod,"propValues",()=>{const t={};for(const i of n.options){const s=i._zod.propValues;if(!s||Object.keys(s).length===0)throw new Error(`Invalid discriminated union option at index "${n.options.indexOf(i)}"`);for(const[u,c]of Object.entries(s)){t[u]||(t[u]=new Set);for(const a of c)t[u].add(a)}}return t});const o=D(()=>{const t=n.options,i=new Map;for(const s of t){const u=s._zod.propValues?.[n.discriminator];if(!u||u.size===0)throw new Error(`Invalid discriminated union option at index "${n.options.indexOf(s)}"`);for(const c of u){if(i.has(c))throw new Error(`Duplicate discriminator value "${String(c)}"`);i.set(c,s)}}return i});e._zod.parse=(t,i)=>{const s=t.value;if(!j(s))return t.issues.push({code:"invalid_type",expected:"object",input:s,inst:e}),t;const u=o.value.get(s?.[n.discriminator]);return u?u._zod.run(t,i):n.unionFallback?r(t,i):(t.issues.push({code:"invalid_union",errors:[],note:"No matching discriminator",discriminator:n.discriminator,input:s,path:[n.discriminator],inst:e}),t)}}),ye=f("$ZodTuple",(e,n)=>{h.init(e,n);const r=n.items,o=r.length-[...r].reverse().findIndex(t=>t._zod.optin!=="optional");e._zod.parse=(t,i)=>{const s=t.value;if(!Array.isArray(s))return t.issues.push({input:s,inst:e,expected:"tuple",code:"invalid_type"}),t;t.value=[];const u=[];if(!n.rest){const a=s.length>r.length,l=s.length<o-1;if(a||l)return t.issues.push({...a?{code:"too_big",maximum:r.length}:{code:"too_small",minimum:r.length},input:s,inst:e,origin:"array"}),t}let c=-1;for(const a of r){if(c++,c>=s.length&&c>=o)continue;const l=a._zod.run({value:s[c],issues:[]},i);l instanceof Promise?u.push(l.then(d=>$(d,t,c))):$(l,t,c)}if(n.rest){const a=s.slice(r.length);for(const l of a){c++;const d=n.rest._zod.run({value:l,issues:[]},i);d instanceof Promise?u.push(d.then(m=>$(m,t,c))):$(d,t,c)}}return u.length?Promise.all(u).then(()=>t):t}});function $(e,n,r){e.issues.length&&n.issues.push(...A(r,e.issues)),n.value[r]=e.value}const Ze=f("$ZodEnum",(e,n)=>{h.init(e,n);const r=q(n.entries),o=new Set(r);e._zod.values=o,e._zod.pattern=new RegExp(`^(${r.filter(t=>X.has(typeof t)).map(t=>typeof t=="string"?S(t):t.toString()).join("|")})$`),e._zod.parse=(t,i)=>{const s=t.value;return o.has(s)||t.issues.push({code:"invalid_value",values:r,input:s,inst:e}),t}}),Pe=f("$ZodLiteral",(e,n)=>{if(h.init(e,n),n.values.length===0)throw new Error("Cannot create literal schema with no valid values");e._zod.values=new Set(n.values),e._zod.pattern=new RegExp(`^(${n.values.map(r=>typeof r=="string"?S(r):r?S(r.toString()):String(r)).join("|")})$`),e._zod.parse=(r,o)=>{const t=r.value;return e._zod.values.has(t)||r.issues.push({code:"invalid_value",values:n.values,input:t,inst:e}),r}}),$e=f("$ZodTransform",(e,n)=>{h.init(e,n),e._zod.parse=(r,o)=>{if(o.direction==="backward")throw new G(e.constructor.name);const t=n.transform(r.value,r);if(o.async)return(t instanceof Promise?t:Promise.resolve(t)).then(s=>(r.value=s,r));if(t instanceof Promise)throw new g;return r.value=t,r}});function C(e,n){return e.issues.length&&n===void 0?{issues:[],value:void 0}:e}const Oe=f("$ZodOptional",(e,n)=>{h.init(e,n),e._zod.optin="optional",e._zod.optout="optional",p(e._zod,"values",()=>n.innerType._zod.values?new Set([...n.innerType._zod.values,void 0]):void 0),p(e._zod,"pattern",()=>{const r=n.innerType._zod.pattern;return r?new RegExp(`^(${T(r.source)})?$`):void 0}),e._zod.parse=(r,o)=>{if(n.innerType._zod.optin==="optional"){const t=n.innerType._zod.run(r,o);return t instanceof Promise?t.then(i=>C(i,r.value)):C(t,r.value)}return r.value===void 0?r:n.innerType._zod.run(r,o)}}),je=f("$ZodNullable",(e,n)=>{h.init(e,n),p(e._zod,"optin",()=>n.innerType._zod.optin),p(e._zod,"optout",()=>n.innerType._zod.optout),p(e._zod,"pattern",()=>{const r=n.innerType._zod.pattern;return r?new RegExp(`^(${T(r.source)}|null)$`):void 0}),p(e._zod,"values",()=>n.innerType._zod.values?new Set([...n.innerType._zod.values,null]):void 0),e._zod.parse=(r,o)=>r.value===null?r:n.innerType._zod.run(r,o)}),ke=f("$ZodPrefault",(e,n)=>{h.init(e,n),e._zod.optin="optional",p(e._zod,"values",()=>n.innerType._zod.values),e._zod.parse=(r,o)=>(o.direction==="backward"||r.value===void 0&&(r.value=n.defaultValue),n.innerType._zod.run(r,o))}),Ee=f("$ZodPipe",(e,n)=>{h.init(e,n),p(e._zod,"values",()=>n.in._zod.values),p(e._zod,"optin",()=>n.in._zod.optin),p(e._zod,"optout",()=>n.out._zod.optout),p(e._zod,"propValues",()=>n.in._zod.propValues),e._zod.parse=(r,o)=>{if(o.direction==="backward"){const i=n.out._zod.run(r,o);return i instanceof Promise?i.then(s=>O(s,n.in,o)):O(i,n.in,o)}const t=n.in._zod.run(r,o);return t instanceof Promise?t.then(i=>O(i,n.out,o)):O(t,n.out,o)}});function O(e,n,r){return e.issues.length?(e.aborted=!0,e):n._zod.run({value:e.value,issues:e.issues},r)}function Se(e,n){return new e({type:"string",...z()})}function Te(e,n){return new e({type:"number",checks:[],...z()})}function Me(e,n){return new e({type:"boolean",...z()})}const _=f("ZodMiniType",(e,n)=>{if(!e._zod)throw new Error("Uninitialized schema in ZodMiniType.");h.init(e,n),e.def=n,e.type=n.type,e.parse=(r,o)=>oe(e,r,o,{callee:e.parse}),e.safeParse=(r,o)=>K(e,r,o),e.parseAsync=async(r,o)=>ie(e,r,o,{callee:e.parseAsync}),e.safeParseAsync=async(r,o)=>F(e,r,o),e.check=(...r)=>e.clone({...n,checks:[...n.checks??[],...r.map(o=>typeof o=="function"?{_zod:{check:o,def:{check:"custom"},onattach:[]}}:o)]}),e.clone=(r,o)=>M(e,r,o),e.brand=()=>e,e.register=((r,o)=>(r.add(e,o),e))}),Ae=f("ZodMiniString",(e,n)=>{de.init(e,n),_.init(e,n)});function Ge(e){return Se(Ae)}const Ne=f("ZodMiniNumber",(e,n)=>{he.init(e,n),_.init(e,n)});function Je(e){return Te(Ne)}const Re=f("ZodMiniBoolean",(e,n)=>{_e.init(e,n),_.init(e,n)});function qe(e){return Me(Re)}const Ue=f("ZodMiniArray",(e,n)=>{me.init(e,n),_.init(e,n)});function He(e,n){return new Ue({type:"array",element:e,...z()})}const Ce=f("ZodMiniObject",(e,n)=>{ge.init(e,n),_.init(e,n),p(e,"shape",()=>n.shape)});function Qe(e,n){const r={type:"object",shape:e??{},...z()};return new Ce(r)}function Xe(e,n){return ne(e,n)}function Ye(e,n){return ee(e,n)}const De=f("ZodMiniDiscriminatedUnion",(e,n)=>{we.init(e,n),_.init(e,n)});function en(e,n,r){return new De({type:"union",options:n,discriminator:e,...z()})}const Ie=f("ZodMiniTuple",(e,n)=>{ye.init(e,n),_.init(e,n)});function nn(e,n,r){const t=n instanceof h?n:null;return new Ie({type:"tuple",items:e,rest:t,...z()})}const xe=f("ZodMiniEnum",(e,n)=>{Ze.init(e,n),_.init(e,n),e.options=Object.values(n.entries)});function rn(e,n){const r=Array.isArray(e)?Object.fromEntries(e.map(o=>[o,o])):e;return new xe({type:"enum",entries:r,...z()})}const Le=f("ZodMiniLiteral",(e,n)=>{Pe.init(e,n),_.init(e,n)});function tn(e,n){return new Le({type:"literal",values:Array.isArray(e)?e:[e],...z()})}const Ve=f("ZodMiniTransform",(e,n)=>{$e.init(e,n),_.init(e,n)});function on(e){return new Ve({type:"transform",transform:e})}const Be=f("ZodMiniOptional",(e,n)=>{Oe.init(e,n),_.init(e,n)});function sn(e){return new Be({type:"optional",innerType:e})}const Ke=f("ZodMiniNullable",(e,n)=>{je.init(e,n),_.init(e,n)});function un(e){return new Ke({type:"nullable",innerType:e})}const Fe=f("ZodMiniPrefault",(e,n)=>{ke.init(e,n),_.init(e,n)});function cn(e,n){return new Fe({type:"prefault",innerType:e,get defaultValue(){return typeof n=="function"?n():Q(n)}})}const We=f("ZodMiniPipe",(e,n)=>{Ee.init(e,n),_.init(e,n)});function an(e,n){return new We({type:"pipe",in:e,out:n})}export{rn as _,He as a,sn as b,qe as c,en as d,un as e,Xe as f,Ye as g,cn as h,nn as i,tn as l,Je as n,Qe as o,an as p,Ge as s,on as t};
